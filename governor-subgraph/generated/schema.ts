// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Account extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Account must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Account", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Account | null {
    return changetype<Account | null>(store.get("Account", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asGovernor(): Bytes | null {
    let value = this.get("asGovernor");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asGovernor(value: Bytes | null) {
    if (!value) {
      this.unset("asGovernor");
    } else {
      this.set("asGovernor", Value.fromBytes(<Bytes>value));
    }
  }

  get proposed(): Array<string> {
    let value = this.get("proposed");
    return value!.toStringArray();
  }

  set proposed(value: Array<string>) {
    this.set("proposed", Value.fromStringArray(value));
  }

  get voted(): Array<string> {
    let value = this.get("voted");
    return value!.toStringArray();
  }

  set voted(value: Array<string>) {
    this.set("voted", Value.fromStringArray(value));
  }

  get proposedCalls(): Array<string> {
    let value = this.get("proposedCalls");
    return value!.toStringArray();
  }

  set proposedCalls(value: Array<string>) {
    this.set("proposedCalls", Value.fromStringArray(value));
  }

  get events(): Array<string> {
    let value = this.get("events");
    return value!.toStringArray();
  }

  set events(value: Array<string>) {
    this.set("events", Value.fromStringArray(value));
  }
}

export class Governor extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Governor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Governor must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Governor", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Governor | null {
    return changetype<Governor | null>(store.get("Governor", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    return value!.toBytes();
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get mode(): string | null {
    let value = this.get("mode");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set mode(value: string | null) {
    if (!value) {
      this.unset("mode");
    } else {
      this.set("mode", Value.fromString(<string>value));
    }
  }

  get proposals(): Array<string> {
    let value = this.get("proposals");
    return value!.toStringArray();
  }

  set proposals(value: Array<string>) {
    this.set("proposals", Value.fromStringArray(value));
  }

  get proposalCreated(): Array<string> {
    let value = this.get("proposalCreated");
    return value!.toStringArray();
  }

  set proposalCreated(value: Array<string>) {
    this.set("proposalCreated", Value.fromStringArray(value));
  }

  get proposalQueued(): Array<string> {
    let value = this.get("proposalQueued");
    return value!.toStringArray();
  }

  set proposalQueued(value: Array<string>) {
    this.set("proposalQueued", Value.fromStringArray(value));
  }

  get proposalExecuted(): Array<string> {
    let value = this.get("proposalExecuted");
    return value!.toStringArray();
  }

  set proposalExecuted(value: Array<string>) {
    this.set("proposalExecuted", Value.fromStringArray(value));
  }

  get proposalCanceled(): Array<string> {
    let value = this.get("proposalCanceled");
    return value!.toStringArray();
  }

  set proposalCanceled(value: Array<string>) {
    this.set("proposalCanceled", Value.fromStringArray(value));
  }

  get votecast(): Array<string> {
    let value = this.get("votecast");
    return value!.toStringArray();
  }

  set votecast(value: Array<string>) {
    this.set("votecast", Value.fromStringArray(value));
  }
}

export class Proposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Proposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Proposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Proposal", id.toString(), this);
    }
  }

  static load(id: string): Proposal | null {
    return changetype<Proposal | null>(store.get("Proposal", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    return value!.toBytes();
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposalId(): BigInt {
    let value = this.get("proposalId");
    return value!.toBigInt();
  }

  set proposalId(value: BigInt) {
    this.set("proposalId", Value.fromBigInt(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    return value!.toBytes();
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get startBlock(): BigInt {
    let value = this.get("startBlock");
    return value!.toBigInt();
  }

  set startBlock(value: BigInt) {
    this.set("startBlock", Value.fromBigInt(value));
  }

  get endBlock(): BigInt {
    let value = this.get("endBlock");
    return value!.toBigInt();
  }

  set endBlock(value: BigInt) {
    this.set("endBlock", Value.fromBigInt(value));
  }

  get description(): string {
    let value = this.get("description");
    return value!.toString();
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get eta(): BigInt | null {
    let value = this.get("eta");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set eta(value: BigInt | null) {
    if (!value) {
      this.unset("eta");
    } else {
      this.set("eta", Value.fromBigInt(<BigInt>value));
    }
  }

  get canceled(): boolean {
    let value = this.get("canceled");
    return value!.toBoolean();
  }

  set canceled(value: boolean) {
    this.set("canceled", Value.fromBoolean(value));
  }

  get queued(): boolean {
    let value = this.get("queued");
    return value!.toBoolean();
  }

  set queued(value: boolean) {
    this.set("queued", Value.fromBoolean(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    return value!.toBoolean();
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get calls(): Array<string> {
    let value = this.get("calls");
    return value!.toStringArray();
  }

  set calls(value: Array<string>) {
    this.set("calls", Value.fromStringArray(value));
  }

  get supports(): Array<string> {
    let value = this.get("supports");
    return value!.toStringArray();
  }

  set supports(value: Array<string>) {
    this.set("supports", Value.fromStringArray(value));
  }

  get receipts(): Array<string> {
    let value = this.get("receipts");
    return value!.toStringArray();
  }

  set receipts(value: Array<string>) {
    this.set("receipts", Value.fromStringArray(value));
  }

  get proposalCreated(): Array<string> {
    let value = this.get("proposalCreated");
    return value!.toStringArray();
  }

  set proposalCreated(value: Array<string>) {
    this.set("proposalCreated", Value.fromStringArray(value));
  }

  get proposalQueued(): Array<string> {
    let value = this.get("proposalQueued");
    return value!.toStringArray();
  }

  set proposalQueued(value: Array<string>) {
    this.set("proposalQueued", Value.fromStringArray(value));
  }

  get proposalExecuted(): Array<string> {
    let value = this.get("proposalExecuted");
    return value!.toStringArray();
  }

  set proposalExecuted(value: Array<string>) {
    this.set("proposalExecuted", Value.fromStringArray(value));
  }

  get proposalCanceled(): Array<string> {
    let value = this.get("proposalCanceled");
    return value!.toStringArray();
  }

  set proposalCanceled(value: Array<string>) {
    this.set("proposalCanceled", Value.fromStringArray(value));
  }

  get votecast(): Array<string> {
    let value = this.get("votecast");
    return value!.toStringArray();
  }

  set votecast(value: Array<string>) {
    this.set("votecast", Value.fromStringArray(value));
  }
}

export class ProposalCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCall entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCall must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProposalCall", id.toString(), this);
    }
  }

  static load(id: string): ProposalCall | null {
    return changetype<ProposalCall | null>(store.get("ProposalCall", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get index(): i32 {
    let value = this.get("index");
    return value!.toI32();
  }

  set index(value: i32) {
    this.set("index", Value.fromI32(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    return value!.toBytes();
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get value(): BigDecimal {
    let value = this.get("value");
    return value!.toBigDecimal();
  }

  set value(value: BigDecimal) {
    this.set("value", Value.fromBigDecimal(value));
  }

  get signature(): string {
    let value = this.get("signature");
    return value!.toString();
  }

  set signature(value: string) {
    this.set("signature", Value.fromString(value));
  }

  get calldata(): Bytes {
    let value = this.get("calldata");
    return value!.toBytes();
  }

  set calldata(value: Bytes) {
    this.set("calldata", Value.fromBytes(value));
  }
}

export class ProposalSupport extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalSupport entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalSupport must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProposalSupport", id.toString(), this);
    }
  }

  static load(id: string): ProposalSupport | null {
    return changetype<ProposalSupport | null>(store.get("ProposalSupport", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get support(): i32 {
    let value = this.get("support");
    return value!.toI32();
  }

  set support(value: i32) {
    this.set("support", Value.fromI32(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get votes(): Array<string> {
    let value = this.get("votes");
    return value!.toStringArray();
  }

  set votes(value: Array<string>) {
    this.set("votes", Value.fromStringArray(value));
  }
}

export class VoteReceipt extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteReceipt entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteReceipt must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VoteReceipt", id.toString(), this);
    }
  }

  static load(id: string): VoteReceipt | null {
    return changetype<VoteReceipt | null>(store.get("VoteReceipt", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    return value!.toBytes();
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get support(): string {
    let value = this.get("support");
    return value!.toString();
  }

  set support(value: string) {
    this.set("support", Value.fromString(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get reason(): string {
    let value = this.get("reason");
    return value!.toString();
  }

  set reason(value: string) {
    this.set("reason", Value.fromString(value));
  }

  get params(): Bytes | null {
    let value = this.get("params");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set params(value: Bytes | null) {
    if (!value) {
      this.unset("params");
    } else {
      this.set("params", Value.fromBytes(<Bytes>value));
    }
  }
}

export class ProposalCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProposalCreated", id.toString(), this);
    }
  }

  static load(id: string): ProposalCreated | null {
    return changetype<ProposalCreated | null>(store.get("ProposalCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    return value!.toBytes();
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    return value!.toBytes();
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    return value!.toBytes();
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }
}

export class ProposalQueued extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalQueued entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalQueued must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProposalQueued", id.toString(), this);
    }
  }

  static load(id: string): ProposalQueued | null {
    return changetype<ProposalQueued | null>(store.get("ProposalQueued", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    return value!.toBytes();
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    return value!.toBytes();
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get eta(): BigInt {
    let value = this.get("eta");
    return value!.toBigInt();
  }

  set eta(value: BigInt) {
    this.set("eta", Value.fromBigInt(value));
  }
}

export class ProposalExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalExecuted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProposalExecuted", id.toString(), this);
    }
  }

  static load(id: string): ProposalExecuted | null {
    return changetype<ProposalExecuted | null>(
      store.get("ProposalExecuted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    return value!.toBytes();
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    return value!.toBytes();
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }
}

export class ProposalCanceled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposalCanceled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposalCanceled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProposalCanceled", id.toString(), this);
    }
  }

  static load(id: string): ProposalCanceled | null {
    return changetype<ProposalCanceled | null>(
      store.get("ProposalCanceled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    return value!.toBytes();
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    return value!.toBytes();
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }
}

export class VoteCast extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VoteCast entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VoteCast must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VoteCast", id.toString(), this);
    }
  }

  static load(id: string): VoteCast | null {
    return changetype<VoteCast | null>(store.get("VoteCast", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    return value!.toBytes();
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get governor(): Bytes {
    let value = this.get("governor");
    return value!.toBytes();
  }

  set governor(value: Bytes) {
    this.set("governor", Value.fromBytes(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    return value!.toString();
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get support(): string {
    let value = this.get("support");
    return value!.toString();
  }

  set support(value: string) {
    this.set("support", Value.fromString(value));
  }

  get receipt(): string {
    let value = this.get("receipt");
    return value!.toString();
  }

  set receipt(value: string) {
    this.set("receipt", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    return value!.toBytes();
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }
}

export class Transaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Transaction", id.toString(), this);
    }
  }

  static load(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get("Transaction", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get events(): Array<string> {
    let value = this.get("events");
    return value!.toStringArray();
  }

  set events(value: Array<string>) {
    this.set("events", Value.fromStringArray(value));
  }
}
